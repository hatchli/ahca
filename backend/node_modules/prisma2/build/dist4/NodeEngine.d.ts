/// <reference types="node" />
import { Engine, QueryEngineError } from './Engine';
import { Platform } from '@prisma/get-platform';
import { GeneratorConfig } from '@prisma/generator-helper';
import { RustLog, RustError } from './log';
import { ChildProcessWithoutNullStreams } from 'child_process';
export interface DatasourceOverwrite {
    name: string;
    url: string;
}
export interface EngineConfig {
    cwd?: string;
    datamodelPath: string;
    debug?: boolean;
    prismaPath?: string;
    fetcher?: (query: string) => Promise<{
        data?: any;
        error?: any;
    }>;
    generator?: GeneratorConfig;
    datasources?: DatasourceOverwrite[];
    showColors?: boolean;
    logQueries?: boolean;
    logLevel?: 'info' | 'warn';
}
export declare class NodeEngine extends Engine {
    private logEmitter;
    private showColors;
    private keepaliveAgent;
    private logQueries;
    private logLevel?;
    port?: number;
    debug: boolean;
    child?: ChildProcessWithoutNullStreams;
    /**
     * exiting is used to tell the .on('exit') hook, if the exit came from our script.
     * As soon as the Prisma binary returns a correct return code (like 1 or 0), we don't need this anymore
     */
    exiting: boolean;
    managementApiEnabled: boolean;
    datamodelJson?: string;
    cwd: string;
    datamodelPath: string;
    prismaPath?: string;
    url: string;
    ready: boolean;
    stderrLogs: string;
    stdoutLogs: string;
    currentRequestPromise?: any;
    cwdPromise: Promise<string>;
    platformPromise: Promise<Platform>;
    platform?: Platform | string;
    generator?: GeneratorConfig;
    incorrectlyPinnedPlatform?: string;
    datasources?: DatasourceOverwrite[];
    lastErrorLog?: RustLog;
    lastError?: RustError;
    startPromise?: Promise<any>;
    constructor({ cwd, datamodelPath, prismaPath, generator, datasources, showColors, logLevel, logQueries, ...args }: EngineConfig);
    private resolveCwd;
    on(event: 'query' | 'info' | 'warn', listener: (log: RustLog) => any): void;
    getPlatform(): Promise<Platform>;
    private getQueryEnginePath;
    private handlePanic;
    private resolvePrismaPath;
    private resolveAlternativeBinaryPath;
    private getPrismaPath;
    printDatasources(): string;
    /**
     * Starts the engine, returns the url that it runs on
     */
    start(): Promise<void>;
    private internalStart;
    fail: (e: any, why: any) => Promise<void>;
    /**
     * If Prisma runs, stop it
     */
    stop(): Promise<void>;
    /**
     * Use the port 0 trick to get a new port
     */
    protected getFreePort(): Promise<number>;
    /**
     * Make sure that our internal port is not conflicting with the prisma.yml's port
     * @param str config
     */
    protected trimPort(str: string): string;
    protected engineReady(): Promise<void>;
    request<T>(query: string, collectTimestamps: any): Promise<T>;
    private serializeErrors;
    handleErrors({ errors, query }: {
        errors?: QueryEngineError[];
        query: string;
    }): void;
}
